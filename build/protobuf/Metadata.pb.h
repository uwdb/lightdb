// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Metadata.proto

#ifndef PROTOBUF_Metadata_2eproto__INCLUDED
#define PROTOBUF_Metadata_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace lightdb {
namespace serialization {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Metadata_2eproto();
void protobuf_AssignDesc_Metadata_2eproto();
void protobuf_ShutdownFile_Metadata_2eproto();

class Metadata;
class Metadata_Volume;
class Metadata_Equirectangular;
class Metadata_Equirectangular_Samples;
class Metadata_Entry;

enum Metadata_EntryType {
  Metadata_EntryType_COMPOSITE = 0,
  Metadata_EntryType_POINT = 1,
  Metadata_EntryType_PLANE = 2
};
bool Metadata_EntryType_IsValid(int value);
const Metadata_EntryType Metadata_EntryType_EntryType_MIN = Metadata_EntryType_COMPOSITE;
const Metadata_EntryType Metadata_EntryType_EntryType_MAX = Metadata_EntryType_PLANE;
const int Metadata_EntryType_EntryType_ARRAYSIZE = Metadata_EntryType_EntryType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Metadata_EntryType_descriptor();
inline const ::std::string& Metadata_EntryType_Name(Metadata_EntryType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Metadata_EntryType_descriptor(), value);
}
inline bool Metadata_EntryType_Parse(
    const ::std::string& name, Metadata_EntryType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Metadata_EntryType>(
    Metadata_EntryType_descriptor(), name, value);
}
// ===================================================================

class Metadata_Volume : public ::google::protobuf::Message {
 public:
  Metadata_Volume();
  virtual ~Metadata_Volume();

  Metadata_Volume(const Metadata_Volume& from);

  inline Metadata_Volume& operator=(const Metadata_Volume& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Metadata_Volume& default_instance();

  void Swap(Metadata_Volume* other);

  // implements Message ----------------------------------------------

  Metadata_Volume* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Metadata_Volume& from);
  void MergeFrom(const Metadata_Volume& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double x1 = 1;
  inline bool has_x1() const;
  inline void clear_x1();
  static const int kX1FieldNumber = 1;
  inline double x1() const;
  inline void set_x1(double value);

  // optional double x2 = 2;
  inline bool has_x2() const;
  inline void clear_x2();
  static const int kX2FieldNumber = 2;
  inline double x2() const;
  inline void set_x2(double value);

  // optional double y1 = 3;
  inline bool has_y1() const;
  inline void clear_y1();
  static const int kY1FieldNumber = 3;
  inline double y1() const;
  inline void set_y1(double value);

  // optional double y2 = 4;
  inline bool has_y2() const;
  inline void clear_y2();
  static const int kY2FieldNumber = 4;
  inline double y2() const;
  inline void set_y2(double value);

  // optional double z1 = 5;
  inline bool has_z1() const;
  inline void clear_z1();
  static const int kZ1FieldNumber = 5;
  inline double z1() const;
  inline void set_z1(double value);

  // optional double z2 = 6;
  inline bool has_z2() const;
  inline void clear_z2();
  static const int kZ2FieldNumber = 6;
  inline double z2() const;
  inline void set_z2(double value);

  // optional double t1 = 7;
  inline bool has_t1() const;
  inline void clear_t1();
  static const int kT1FieldNumber = 7;
  inline double t1() const;
  inline void set_t1(double value);

  // optional double t2 = 8;
  inline bool has_t2() const;
  inline void clear_t2();
  static const int kT2FieldNumber = 8;
  inline double t2() const;
  inline void set_t2(double value);

  // optional double theta1 = 9;
  inline bool has_theta1() const;
  inline void clear_theta1();
  static const int kTheta1FieldNumber = 9;
  inline double theta1() const;
  inline void set_theta1(double value);

  // optional double theta2 = 10;
  inline bool has_theta2() const;
  inline void clear_theta2();
  static const int kTheta2FieldNumber = 10;
  inline double theta2() const;
  inline void set_theta2(double value);

  // optional double phi1 = 11;
  inline bool has_phi1() const;
  inline void clear_phi1();
  static const int kPhi1FieldNumber = 11;
  inline double phi1() const;
  inline void set_phi1(double value);

  // optional double phi2 = 12;
  inline bool has_phi2() const;
  inline void clear_phi2();
  static const int kPhi2FieldNumber = 12;
  inline double phi2() const;
  inline void set_phi2(double value);

  // @@protoc_insertion_point(class_scope:lightdb.serialization.Metadata.Volume)
 private:
  inline void set_has_x1();
  inline void clear_has_x1();
  inline void set_has_x2();
  inline void clear_has_x2();
  inline void set_has_y1();
  inline void clear_has_y1();
  inline void set_has_y2();
  inline void clear_has_y2();
  inline void set_has_z1();
  inline void clear_has_z1();
  inline void set_has_z2();
  inline void clear_has_z2();
  inline void set_has_t1();
  inline void clear_has_t1();
  inline void set_has_t2();
  inline void clear_has_t2();
  inline void set_has_theta1();
  inline void clear_has_theta1();
  inline void set_has_theta2();
  inline void clear_has_theta2();
  inline void set_has_phi1();
  inline void clear_has_phi1();
  inline void set_has_phi2();
  inline void clear_has_phi2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double x1_;
  double x2_;
  double y1_;
  double y2_;
  double z1_;
  double z2_;
  double t1_;
  double t2_;
  double theta1_;
  double theta2_;
  double phi1_;
  double phi2_;
  friend void  protobuf_AddDesc_Metadata_2eproto();
  friend void protobuf_AssignDesc_Metadata_2eproto();
  friend void protobuf_ShutdownFile_Metadata_2eproto();

  void InitAsDefaultInstance();
  static Metadata_Volume* default_instance_;
};
// -------------------------------------------------------------------

class Metadata_Equirectangular_Samples : public ::google::protobuf::Message {
 public:
  Metadata_Equirectangular_Samples();
  virtual ~Metadata_Equirectangular_Samples();

  Metadata_Equirectangular_Samples(const Metadata_Equirectangular_Samples& from);

  inline Metadata_Equirectangular_Samples& operator=(const Metadata_Equirectangular_Samples& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Metadata_Equirectangular_Samples& default_instance();

  void Swap(Metadata_Equirectangular_Samples* other);

  // implements Message ----------------------------------------------

  Metadata_Equirectangular_Samples* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Metadata_Equirectangular_Samples& from);
  void MergeFrom(const Metadata_Equirectangular_Samples& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::uint32 x() const;
  inline void set_x(::google::protobuf::uint32 value);

  // optional uint32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::uint32 y() const;
  inline void set_y(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:lightdb.serialization.Metadata.Equirectangular.Samples)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 x_;
  ::google::protobuf::uint32 y_;
  friend void  protobuf_AddDesc_Metadata_2eproto();
  friend void protobuf_AssignDesc_Metadata_2eproto();
  friend void protobuf_ShutdownFile_Metadata_2eproto();

  void InitAsDefaultInstance();
  static Metadata_Equirectangular_Samples* default_instance_;
};
// -------------------------------------------------------------------

class Metadata_Equirectangular : public ::google::protobuf::Message {
 public:
  Metadata_Equirectangular();
  virtual ~Metadata_Equirectangular();

  Metadata_Equirectangular(const Metadata_Equirectangular& from);

  inline Metadata_Equirectangular& operator=(const Metadata_Equirectangular& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Metadata_Equirectangular& default_instance();

  void Swap(Metadata_Equirectangular* other);

  // implements Message ----------------------------------------------

  Metadata_Equirectangular* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Metadata_Equirectangular& from);
  void MergeFrom(const Metadata_Equirectangular& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Metadata_Equirectangular_Samples Samples;

  // accessors -------------------------------------------------------

  // optional .lightdb.serialization.Metadata.Equirectangular.Samples samples = 1;
  inline bool has_samples() const;
  inline void clear_samples();
  static const int kSamplesFieldNumber = 1;
  inline const ::lightdb::serialization::Metadata_Equirectangular_Samples& samples() const;
  inline ::lightdb::serialization::Metadata_Equirectangular_Samples* mutable_samples();
  inline ::lightdb::serialization::Metadata_Equirectangular_Samples* release_samples();
  inline void set_allocated_samples(::lightdb::serialization::Metadata_Equirectangular_Samples* samples);

  // @@protoc_insertion_point(class_scope:lightdb.serialization.Metadata.Equirectangular)
 private:
  inline void set_has_samples();
  inline void clear_has_samples();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::lightdb::serialization::Metadata_Equirectangular_Samples* samples_;
  friend void  protobuf_AddDesc_Metadata_2eproto();
  friend void protobuf_AssignDesc_Metadata_2eproto();
  friend void protobuf_ShutdownFile_Metadata_2eproto();

  void InitAsDefaultInstance();
  static Metadata_Equirectangular* default_instance_;
};
// -------------------------------------------------------------------

class Metadata_Entry : public ::google::protobuf::Message {
 public:
  Metadata_Entry();
  virtual ~Metadata_Entry();

  Metadata_Entry(const Metadata_Entry& from);

  inline Metadata_Entry& operator=(const Metadata_Entry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Metadata_Entry& default_instance();

  enum ProjectionCase {
    kEquirectangular = 3,
    PROJECTION_NOT_SET = 0,
  };

  void Swap(Metadata_Entry* other);

  // implements Message ----------------------------------------------

  Metadata_Entry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Metadata_Entry& from);
  void MergeFrom(const Metadata_Entry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .lightdb.serialization.Metadata.EntryType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::lightdb::serialization::Metadata_EntryType type() const;
  inline void set_type(::lightdb::serialization::Metadata_EntryType value);

  // repeated .lightdb.serialization.Metadata.Volume partitions = 2;
  inline int partitions_size() const;
  inline void clear_partitions();
  static const int kPartitionsFieldNumber = 2;
  inline const ::lightdb::serialization::Metadata_Volume& partitions(int index) const;
  inline ::lightdb::serialization::Metadata_Volume* mutable_partitions(int index);
  inline ::lightdb::serialization::Metadata_Volume* add_partitions();
  inline const ::google::protobuf::RepeatedPtrField< ::lightdb::serialization::Metadata_Volume >&
      partitions() const;
  inline ::google::protobuf::RepeatedPtrField< ::lightdb::serialization::Metadata_Volume >*
      mutable_partitions();

  // optional .lightdb.serialization.Metadata.Equirectangular equirectangular = 3;
  inline bool has_equirectangular() const;
  inline void clear_equirectangular();
  static const int kEquirectangularFieldNumber = 3;
  inline const ::lightdb::serialization::Metadata_Equirectangular& equirectangular() const;
  inline ::lightdb::serialization::Metadata_Equirectangular* mutable_equirectangular();
  inline ::lightdb::serialization::Metadata_Equirectangular* release_equirectangular();
  inline void set_allocated_equirectangular(::lightdb::serialization::Metadata_Equirectangular* equirectangular);

  inline ProjectionCase projection_case() const;
  // @@protoc_insertion_point(class_scope:lightdb.serialization.Metadata.Entry)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_equirectangular();

  inline bool has_projection();
  void clear_projection();
  inline void clear_has_projection();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::lightdb::serialization::Metadata_Volume > partitions_;
  int type_;
  union ProjectionUnion {
    ::lightdb::serialization::Metadata_Equirectangular* equirectangular_;
  } projection_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_Metadata_2eproto();
  friend void protobuf_AssignDesc_Metadata_2eproto();
  friend void protobuf_ShutdownFile_Metadata_2eproto();

  void InitAsDefaultInstance();
  static Metadata_Entry* default_instance_;
};
// -------------------------------------------------------------------

class Metadata : public ::google::protobuf::Message {
 public:
  Metadata();
  virtual ~Metadata();

  Metadata(const Metadata& from);

  inline Metadata& operator=(const Metadata& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Metadata& default_instance();

  void Swap(Metadata* other);

  // implements Message ----------------------------------------------

  Metadata* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Metadata& from);
  void MergeFrom(const Metadata& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Metadata_Volume Volume;
  typedef Metadata_Equirectangular Equirectangular;
  typedef Metadata_Entry Entry;

  typedef Metadata_EntryType EntryType;
  static const EntryType COMPOSITE = Metadata_EntryType_COMPOSITE;
  static const EntryType POINT = Metadata_EntryType_POINT;
  static const EntryType PLANE = Metadata_EntryType_PLANE;
  static inline bool EntryType_IsValid(int value) {
    return Metadata_EntryType_IsValid(value);
  }
  static const EntryType EntryType_MIN =
    Metadata_EntryType_EntryType_MIN;
  static const EntryType EntryType_MAX =
    Metadata_EntryType_EntryType_MAX;
  static const int EntryType_ARRAYSIZE =
    Metadata_EntryType_EntryType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EntryType_descriptor() {
    return Metadata_EntryType_descriptor();
  }
  static inline const ::std::string& EntryType_Name(EntryType value) {
    return Metadata_EntryType_Name(value);
  }
  static inline bool EntryType_Parse(const ::std::string& name,
      EntryType* value) {
    return Metadata_EntryType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required uint32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // repeated .lightdb.serialization.Metadata.Entry entries = 2;
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 2;
  inline const ::lightdb::serialization::Metadata_Entry& entries(int index) const;
  inline ::lightdb::serialization::Metadata_Entry* mutable_entries(int index);
  inline ::lightdb::serialization::Metadata_Entry* add_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::lightdb::serialization::Metadata_Entry >&
      entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::lightdb::serialization::Metadata_Entry >*
      mutable_entries();

  // @@protoc_insertion_point(class_scope:lightdb.serialization.Metadata)
 private:
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::lightdb::serialization::Metadata_Entry > entries_;
  ::google::protobuf::uint32 version_;
  friend void  protobuf_AddDesc_Metadata_2eproto();
  friend void protobuf_AssignDesc_Metadata_2eproto();
  friend void protobuf_ShutdownFile_Metadata_2eproto();

  void InitAsDefaultInstance();
  static Metadata* default_instance_;
};
// ===================================================================


// ===================================================================

// Metadata_Volume

// optional double x1 = 1;
inline bool Metadata_Volume::has_x1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Metadata_Volume::set_has_x1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Metadata_Volume::clear_has_x1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Metadata_Volume::clear_x1() {
  x1_ = 0;
  clear_has_x1();
}
inline double Metadata_Volume::x1() const {
  // @@protoc_insertion_point(field_get:lightdb.serialization.Metadata.Volume.x1)
  return x1_;
}
inline void Metadata_Volume::set_x1(double value) {
  set_has_x1();
  x1_ = value;
  // @@protoc_insertion_point(field_set:lightdb.serialization.Metadata.Volume.x1)
}

// optional double x2 = 2;
inline bool Metadata_Volume::has_x2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Metadata_Volume::set_has_x2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Metadata_Volume::clear_has_x2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Metadata_Volume::clear_x2() {
  x2_ = 0;
  clear_has_x2();
}
inline double Metadata_Volume::x2() const {
  // @@protoc_insertion_point(field_get:lightdb.serialization.Metadata.Volume.x2)
  return x2_;
}
inline void Metadata_Volume::set_x2(double value) {
  set_has_x2();
  x2_ = value;
  // @@protoc_insertion_point(field_set:lightdb.serialization.Metadata.Volume.x2)
}

// optional double y1 = 3;
inline bool Metadata_Volume::has_y1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Metadata_Volume::set_has_y1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Metadata_Volume::clear_has_y1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Metadata_Volume::clear_y1() {
  y1_ = 0;
  clear_has_y1();
}
inline double Metadata_Volume::y1() const {
  // @@protoc_insertion_point(field_get:lightdb.serialization.Metadata.Volume.y1)
  return y1_;
}
inline void Metadata_Volume::set_y1(double value) {
  set_has_y1();
  y1_ = value;
  // @@protoc_insertion_point(field_set:lightdb.serialization.Metadata.Volume.y1)
}

// optional double y2 = 4;
inline bool Metadata_Volume::has_y2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Metadata_Volume::set_has_y2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Metadata_Volume::clear_has_y2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Metadata_Volume::clear_y2() {
  y2_ = 0;
  clear_has_y2();
}
inline double Metadata_Volume::y2() const {
  // @@protoc_insertion_point(field_get:lightdb.serialization.Metadata.Volume.y2)
  return y2_;
}
inline void Metadata_Volume::set_y2(double value) {
  set_has_y2();
  y2_ = value;
  // @@protoc_insertion_point(field_set:lightdb.serialization.Metadata.Volume.y2)
}

// optional double z1 = 5;
inline bool Metadata_Volume::has_z1() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Metadata_Volume::set_has_z1() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Metadata_Volume::clear_has_z1() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Metadata_Volume::clear_z1() {
  z1_ = 0;
  clear_has_z1();
}
inline double Metadata_Volume::z1() const {
  // @@protoc_insertion_point(field_get:lightdb.serialization.Metadata.Volume.z1)
  return z1_;
}
inline void Metadata_Volume::set_z1(double value) {
  set_has_z1();
  z1_ = value;
  // @@protoc_insertion_point(field_set:lightdb.serialization.Metadata.Volume.z1)
}

// optional double z2 = 6;
inline bool Metadata_Volume::has_z2() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Metadata_Volume::set_has_z2() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Metadata_Volume::clear_has_z2() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Metadata_Volume::clear_z2() {
  z2_ = 0;
  clear_has_z2();
}
inline double Metadata_Volume::z2() const {
  // @@protoc_insertion_point(field_get:lightdb.serialization.Metadata.Volume.z2)
  return z2_;
}
inline void Metadata_Volume::set_z2(double value) {
  set_has_z2();
  z2_ = value;
  // @@protoc_insertion_point(field_set:lightdb.serialization.Metadata.Volume.z2)
}

// optional double t1 = 7;
inline bool Metadata_Volume::has_t1() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Metadata_Volume::set_has_t1() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Metadata_Volume::clear_has_t1() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Metadata_Volume::clear_t1() {
  t1_ = 0;
  clear_has_t1();
}
inline double Metadata_Volume::t1() const {
  // @@protoc_insertion_point(field_get:lightdb.serialization.Metadata.Volume.t1)
  return t1_;
}
inline void Metadata_Volume::set_t1(double value) {
  set_has_t1();
  t1_ = value;
  // @@protoc_insertion_point(field_set:lightdb.serialization.Metadata.Volume.t1)
}

// optional double t2 = 8;
inline bool Metadata_Volume::has_t2() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Metadata_Volume::set_has_t2() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Metadata_Volume::clear_has_t2() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Metadata_Volume::clear_t2() {
  t2_ = 0;
  clear_has_t2();
}
inline double Metadata_Volume::t2() const {
  // @@protoc_insertion_point(field_get:lightdb.serialization.Metadata.Volume.t2)
  return t2_;
}
inline void Metadata_Volume::set_t2(double value) {
  set_has_t2();
  t2_ = value;
  // @@protoc_insertion_point(field_set:lightdb.serialization.Metadata.Volume.t2)
}

// optional double theta1 = 9;
inline bool Metadata_Volume::has_theta1() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Metadata_Volume::set_has_theta1() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Metadata_Volume::clear_has_theta1() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Metadata_Volume::clear_theta1() {
  theta1_ = 0;
  clear_has_theta1();
}
inline double Metadata_Volume::theta1() const {
  // @@protoc_insertion_point(field_get:lightdb.serialization.Metadata.Volume.theta1)
  return theta1_;
}
inline void Metadata_Volume::set_theta1(double value) {
  set_has_theta1();
  theta1_ = value;
  // @@protoc_insertion_point(field_set:lightdb.serialization.Metadata.Volume.theta1)
}

// optional double theta2 = 10;
inline bool Metadata_Volume::has_theta2() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Metadata_Volume::set_has_theta2() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Metadata_Volume::clear_has_theta2() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Metadata_Volume::clear_theta2() {
  theta2_ = 0;
  clear_has_theta2();
}
inline double Metadata_Volume::theta2() const {
  // @@protoc_insertion_point(field_get:lightdb.serialization.Metadata.Volume.theta2)
  return theta2_;
}
inline void Metadata_Volume::set_theta2(double value) {
  set_has_theta2();
  theta2_ = value;
  // @@protoc_insertion_point(field_set:lightdb.serialization.Metadata.Volume.theta2)
}

// optional double phi1 = 11;
inline bool Metadata_Volume::has_phi1() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Metadata_Volume::set_has_phi1() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Metadata_Volume::clear_has_phi1() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Metadata_Volume::clear_phi1() {
  phi1_ = 0;
  clear_has_phi1();
}
inline double Metadata_Volume::phi1() const {
  // @@protoc_insertion_point(field_get:lightdb.serialization.Metadata.Volume.phi1)
  return phi1_;
}
inline void Metadata_Volume::set_phi1(double value) {
  set_has_phi1();
  phi1_ = value;
  // @@protoc_insertion_point(field_set:lightdb.serialization.Metadata.Volume.phi1)
}

// optional double phi2 = 12;
inline bool Metadata_Volume::has_phi2() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Metadata_Volume::set_has_phi2() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Metadata_Volume::clear_has_phi2() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Metadata_Volume::clear_phi2() {
  phi2_ = 0;
  clear_has_phi2();
}
inline double Metadata_Volume::phi2() const {
  // @@protoc_insertion_point(field_get:lightdb.serialization.Metadata.Volume.phi2)
  return phi2_;
}
inline void Metadata_Volume::set_phi2(double value) {
  set_has_phi2();
  phi2_ = value;
  // @@protoc_insertion_point(field_set:lightdb.serialization.Metadata.Volume.phi2)
}

// -------------------------------------------------------------------

// Metadata_Equirectangular_Samples

// optional uint32 x = 1;
inline bool Metadata_Equirectangular_Samples::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Metadata_Equirectangular_Samples::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Metadata_Equirectangular_Samples::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Metadata_Equirectangular_Samples::clear_x() {
  x_ = 0u;
  clear_has_x();
}
inline ::google::protobuf::uint32 Metadata_Equirectangular_Samples::x() const {
  // @@protoc_insertion_point(field_get:lightdb.serialization.Metadata.Equirectangular.Samples.x)
  return x_;
}
inline void Metadata_Equirectangular_Samples::set_x(::google::protobuf::uint32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:lightdb.serialization.Metadata.Equirectangular.Samples.x)
}

// optional uint32 y = 2;
inline bool Metadata_Equirectangular_Samples::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Metadata_Equirectangular_Samples::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Metadata_Equirectangular_Samples::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Metadata_Equirectangular_Samples::clear_y() {
  y_ = 0u;
  clear_has_y();
}
inline ::google::protobuf::uint32 Metadata_Equirectangular_Samples::y() const {
  // @@protoc_insertion_point(field_get:lightdb.serialization.Metadata.Equirectangular.Samples.y)
  return y_;
}
inline void Metadata_Equirectangular_Samples::set_y(::google::protobuf::uint32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:lightdb.serialization.Metadata.Equirectangular.Samples.y)
}

// -------------------------------------------------------------------

// Metadata_Equirectangular

// optional .lightdb.serialization.Metadata.Equirectangular.Samples samples = 1;
inline bool Metadata_Equirectangular::has_samples() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Metadata_Equirectangular::set_has_samples() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Metadata_Equirectangular::clear_has_samples() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Metadata_Equirectangular::clear_samples() {
  if (samples_ != NULL) samples_->::lightdb::serialization::Metadata_Equirectangular_Samples::Clear();
  clear_has_samples();
}
inline const ::lightdb::serialization::Metadata_Equirectangular_Samples& Metadata_Equirectangular::samples() const {
  // @@protoc_insertion_point(field_get:lightdb.serialization.Metadata.Equirectangular.samples)
  return samples_ != NULL ? *samples_ : *default_instance_->samples_;
}
inline ::lightdb::serialization::Metadata_Equirectangular_Samples* Metadata_Equirectangular::mutable_samples() {
  set_has_samples();
  if (samples_ == NULL) samples_ = new ::lightdb::serialization::Metadata_Equirectangular_Samples;
  // @@protoc_insertion_point(field_mutable:lightdb.serialization.Metadata.Equirectangular.samples)
  return samples_;
}
inline ::lightdb::serialization::Metadata_Equirectangular_Samples* Metadata_Equirectangular::release_samples() {
  clear_has_samples();
  ::lightdb::serialization::Metadata_Equirectangular_Samples* temp = samples_;
  samples_ = NULL;
  return temp;
}
inline void Metadata_Equirectangular::set_allocated_samples(::lightdb::serialization::Metadata_Equirectangular_Samples* samples) {
  delete samples_;
  samples_ = samples;
  if (samples) {
    set_has_samples();
  } else {
    clear_has_samples();
  }
  // @@protoc_insertion_point(field_set_allocated:lightdb.serialization.Metadata.Equirectangular.samples)
}

// -------------------------------------------------------------------

// Metadata_Entry

// required .lightdb.serialization.Metadata.EntryType type = 1;
inline bool Metadata_Entry::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Metadata_Entry::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Metadata_Entry::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Metadata_Entry::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::lightdb::serialization::Metadata_EntryType Metadata_Entry::type() const {
  // @@protoc_insertion_point(field_get:lightdb.serialization.Metadata.Entry.type)
  return static_cast< ::lightdb::serialization::Metadata_EntryType >(type_);
}
inline void Metadata_Entry::set_type(::lightdb::serialization::Metadata_EntryType value) {
  assert(::lightdb::serialization::Metadata_EntryType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:lightdb.serialization.Metadata.Entry.type)
}

// repeated .lightdb.serialization.Metadata.Volume partitions = 2;
inline int Metadata_Entry::partitions_size() const {
  return partitions_.size();
}
inline void Metadata_Entry::clear_partitions() {
  partitions_.Clear();
}
inline const ::lightdb::serialization::Metadata_Volume& Metadata_Entry::partitions(int index) const {
  // @@protoc_insertion_point(field_get:lightdb.serialization.Metadata.Entry.partitions)
  return partitions_.Get(index);
}
inline ::lightdb::serialization::Metadata_Volume* Metadata_Entry::mutable_partitions(int index) {
  // @@protoc_insertion_point(field_mutable:lightdb.serialization.Metadata.Entry.partitions)
  return partitions_.Mutable(index);
}
inline ::lightdb::serialization::Metadata_Volume* Metadata_Entry::add_partitions() {
  // @@protoc_insertion_point(field_add:lightdb.serialization.Metadata.Entry.partitions)
  return partitions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lightdb::serialization::Metadata_Volume >&
Metadata_Entry::partitions() const {
  // @@protoc_insertion_point(field_list:lightdb.serialization.Metadata.Entry.partitions)
  return partitions_;
}
inline ::google::protobuf::RepeatedPtrField< ::lightdb::serialization::Metadata_Volume >*
Metadata_Entry::mutable_partitions() {
  // @@protoc_insertion_point(field_mutable_list:lightdb.serialization.Metadata.Entry.partitions)
  return &partitions_;
}

// optional .lightdb.serialization.Metadata.Equirectangular equirectangular = 3;
inline bool Metadata_Entry::has_equirectangular() const {
  return projection_case() == kEquirectangular;
}
inline void Metadata_Entry::set_has_equirectangular() {
  _oneof_case_[0] = kEquirectangular;
}
inline void Metadata_Entry::clear_equirectangular() {
  if (has_equirectangular()) {
    delete projection_.equirectangular_;
    clear_has_projection();
  }
}
inline const ::lightdb::serialization::Metadata_Equirectangular& Metadata_Entry::equirectangular() const {
  return has_equirectangular() ? *projection_.equirectangular_
                      : ::lightdb::serialization::Metadata_Equirectangular::default_instance();
}
inline ::lightdb::serialization::Metadata_Equirectangular* Metadata_Entry::mutable_equirectangular() {
  if (!has_equirectangular()) {
    clear_projection();
    set_has_equirectangular();
    projection_.equirectangular_ = new ::lightdb::serialization::Metadata_Equirectangular;
  }
  return projection_.equirectangular_;
}
inline ::lightdb::serialization::Metadata_Equirectangular* Metadata_Entry::release_equirectangular() {
  if (has_equirectangular()) {
    clear_has_projection();
    ::lightdb::serialization::Metadata_Equirectangular* temp = projection_.equirectangular_;
    projection_.equirectangular_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Metadata_Entry::set_allocated_equirectangular(::lightdb::serialization::Metadata_Equirectangular* equirectangular) {
  clear_projection();
  if (equirectangular) {
    set_has_equirectangular();
    projection_.equirectangular_ = equirectangular;
  }
}

inline bool Metadata_Entry::has_projection() {
  return projection_case() != PROJECTION_NOT_SET;
}
inline void Metadata_Entry::clear_has_projection() {
  _oneof_case_[0] = PROJECTION_NOT_SET;
}
inline Metadata_Entry::ProjectionCase Metadata_Entry::projection_case() const {
  return Metadata_Entry::ProjectionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Metadata

// required uint32 version = 1;
inline bool Metadata::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Metadata::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Metadata::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Metadata::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 Metadata::version() const {
  // @@protoc_insertion_point(field_get:lightdb.serialization.Metadata.version)
  return version_;
}
inline void Metadata::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:lightdb.serialization.Metadata.version)
}

// repeated .lightdb.serialization.Metadata.Entry entries = 2;
inline int Metadata::entries_size() const {
  return entries_.size();
}
inline void Metadata::clear_entries() {
  entries_.Clear();
}
inline const ::lightdb::serialization::Metadata_Entry& Metadata::entries(int index) const {
  // @@protoc_insertion_point(field_get:lightdb.serialization.Metadata.entries)
  return entries_.Get(index);
}
inline ::lightdb::serialization::Metadata_Entry* Metadata::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:lightdb.serialization.Metadata.entries)
  return entries_.Mutable(index);
}
inline ::lightdb::serialization::Metadata_Entry* Metadata::add_entries() {
  // @@protoc_insertion_point(field_add:lightdb.serialization.Metadata.entries)
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lightdb::serialization::Metadata_Entry >&
Metadata::entries() const {
  // @@protoc_insertion_point(field_list:lightdb.serialization.Metadata.entries)
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::lightdb::serialization::Metadata_Entry >*
Metadata::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:lightdb.serialization.Metadata.entries)
  return &entries_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace serialization
}  // namespace lightdb

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::lightdb::serialization::Metadata_EntryType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::lightdb::serialization::Metadata_EntryType>() {
  return ::lightdb::serialization::Metadata_EntryType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Metadata_2eproto__INCLUDED
